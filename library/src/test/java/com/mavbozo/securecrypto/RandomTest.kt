package com.mavbozo.securecrypto

import android.content.Context
import androidx.test.core.app.ApplicationProvider
import kotlinx.coroutines.runBlocking
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.MockitoAnnotations
import org.robolectric.RobolectricTestRunner
import java.security.Provider
import java.security.SecureRandom
import java.security.Security
import org.bouncycastle.jce.provider.BouncyCastleProvider

@RunWith(RobolectricTestRunner::class)
class RandomTest {
    private lateinit var context: Context

    // Custom provider just for quality detection
    private class TestAndroidKeyStoreProvider : Provider(
        "AndroidKeyStore",
        1.0,
        "Test Android KeyStore Provider"
    ) {
        init {
            // Empty provider - only needed for presence check
        }
    }

    @Before
    fun setup() {
        MockitoAnnotations.openMocks(this)
        context = ApplicationProvider.getApplicationContext()

        // Add providers
        if (Security.getProvider("BC") == null) {
            Security.addProvider(BouncyCastleProvider())
        }

        // Add test provider for quality detection
        if (Security.getProvider("AndroidKeyStore") == null) {
            Security.addProvider(TestAndroidKeyStoreProvider())
        }
    }

    @Test
    fun `test Random creation with hardware quality`() = runBlocking {
        // Add AndroidKeyStore provider to trigger hardware quality
        val randomResult = Random.create()

        assertTrue("Random creation failed", randomResult.isSuccess)
        val random = randomResult.getOrThrow()

        assertEquals("Should detect hardware quality due to AndroidKeyStore presence",
            EntropyQuality.Hardware,
            random.getQuality())
    }

    @Test
    fun `test Random creation with fallback quality`() = runBlocking {
        // Remove AndroidKeyStore provider to trigger fallback quality
        Security.removeProvider("AndroidKeyStore")

        val randomResult = Random.create()
        assertTrue("Random creation failed", randomResult.isSuccess)

        val random = randomResult.getOrThrow()
        assertEquals("Should fall back to software quality",
            EntropyQuality.Fallback,
            random.getQuality())
    }

    @Test
    fun `test generate random bytes`() = runBlocking {
        val size = 32
        val bytesResult = Random.generateBytes(size)

        assertTrue("Generate bytes failed", bytesResult.isSuccess)
        val bytes = bytesResult.getOrThrow()

        assertNotNull("Generated bytes are null", bytes)
        assertEquals("Generated bytes size mismatch", size, bytes.size)
        assertFalse("Generated bytes should not be all zero",
            bytes.all { it == 0.toByte() })
    }

    @Test
    fun `test generate hex string`() = runBlocking {
        val length = 32
        val hexResult = Random.generateHexString(length)

        assertTrue("Hex string generation failed", hexResult.isSuccess)
        val hexString = hexResult.getOrThrow()

        assertNotNull("Generated hex string is null", hexString)
        assertEquals("Hex string length mismatch", length, hexString.length)
        assertTrue("Invalid hex string format",
            hexString.matches(Regex("[0-9a-f]+")))
    }

    @Test
    fun `test secure bytes wrapping and cleanup`() = runBlocking {
        val size = 32
        val randomResult = Random.create()
        assertTrue("Random creation failed", randomResult.isSuccess)

        val random = randomResult.getOrThrow()
        val bytesResult = random.nextSecureBytes(size)
        assertTrue("Secure bytes generation failed", bytesResult.isSuccess)

        val secureBytes = bytesResult.getOrThrow()
        var exposedBytes: ByteArray? = null

        secureBytes.use { bytes ->
            exposedBytes = bytes.clone()
            assertNotNull("Exposed bytes are null", exposedBytes)
            assertEquals("Exposed bytes size mismatch", size, exposedBytes?.size)
            assertFalse("Bytes should not be all zero before cleanup",
                bytes.all { it == 0.toByte() })
        }

        secureBytes.use { bytes ->
            assertTrue("Bytes not zeroed after use",
                bytes.all { it == 0.toByte() })
        }
    }

    @Test
    fun `test negative size handling`() = runBlocking {
        val negativeSize = -1
        val bytesResult = Random.generateBytes(negativeSize)

        assertTrue("Should fail with negative size", bytesResult.isFailure)
        assertTrue("Should have IllegalArgumentException",
            bytesResult.exceptionOrNull() is IllegalArgumentException)
    }
}
package com.mavbozo.androidsecurecrypto

import android.content.Context
import android.content.ContextWrapper
import android.util.Base64
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.runBlocking
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class EnhancedRandomInstrumentedTest {
    private lateinit var context: Context

    @Before
    fun setup() {
        context = InstrumentationRegistry.getInstrumentation().targetContext
    }

    // Basic Functionality Tests
    @Test
    fun testBasicRandomGeneration(): Unit = runBlocking {
        // First, test creation
        val randomResult = EnhancedRandom.create(context)
        assertTrue("Random creation failed: ${randomResult.exceptionOrNull()}",
            randomResult.isSuccess)

        val random = randomResult.getOrThrow()
        val size = 32

        // Then test generation with error logging
        val result = random.nextBytes(size)
        assertTrue("Random generation failed: ${result.exceptionOrNull()}",
            result.isSuccess)

        // Only proceed if we succeeded
        val bytes = result.getOrThrow()
        assertEquals("Generated bytes size mismatch", size, bytes.size)

        // Basic entropy check
        val allZeros = bytes.all { it == 0.toByte() }
        val allOnes = bytes.all { it == (-1).toByte() }
        assertFalse("Generated bytes should not be all zeros", allZeros)
        assertFalse("Generated bytes should not be all ones", allOnes)
    }

    @Test
    fun testEnhancedHexStringGeneration() = runBlocking {
        val length = 32 // We want a 32-character hex string
        val expectedLength = length * 2 // the hex is length of bytes * 2

        val result = EnhancedRandom.generateEnhancedBytesAsHex(context, length)
        assertTrue("Hex string generation failed: ${result.exceptionOrNull()}",
            result.isSuccess)

        val hexString = result.getOrThrow()
        assertEquals("Generated hex string length mismatch", expectedLength, hexString.length)
        assertTrue("Invalid hex string format",
            hexString.matches(Regex("[0-9a-f]+")))
    }

    @Test
    fun testEntropyQualityReporting() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()

        // Since we're using MasterKey and platform SecureRandom,
        // we should always get Hardware quality on modern Android devices
        val quality = random.getQuality()
        assertEquals("Should report hardware-backed entropy",
            EntropyQuality.Hardware, quality)
    }

    @Test
    fun testDistinctSequences() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val size = 32

        // Generate two sequences of the same size
        val sequence1 = random.nextBytes(size).getOrThrow()
        val sequence2 = random.nextBytes(size).getOrThrow()

        // They should be different
        assertFalse("Consecutive generations should produce different values",
            sequence1.contentEquals(sequence2))
    }

    @Test
    fun testNegativeSizeHandling() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()

        // Test direct byte generation
        val bytesResult = random.nextBytes(-1)
        assertTrue("Should fail with negative size", bytesResult.isFailure)
        val bytesError = bytesResult.exceptionOrNull()
        assertTrue("Should have IllegalArgumentException", bytesError is IllegalArgumentException)
        assertEquals("Should have correct error message", "Size must be positive", bytesError?.message)

        // Test SecureBytes generation
        val secureBytesResult = random.nextSecureBytes(-1)
        assertTrue("Should fail with negative size", secureBytesResult.isFailure)
        val secureBytesError = secureBytesResult.exceptionOrNull()
        assertTrue("Should have IllegalArgumentException", secureBytesError is IllegalArgumentException)
        assertEquals("Should have correct error message", "Size must be positive", secureBytesError?.message)

        // Test hex string generation
        val hexResult = EnhancedRandom.generateEnhancedBytesAsHex(context, -1)
        assertTrue("Should fail with negative size", hexResult.isFailure)
        val hexError = hexResult.exceptionOrNull()
        assertTrue("Should have IllegalArgumentException", hexError is IllegalArgumentException)
        assertEquals("Should have correct error message", "Size must be positive", hexError?.message)

        // Test Base64 string generation
        val base64Result = EnhancedRandom.generateEnhancedBytesAsBase64(context, -1)
        assertTrue("Should fail with negative size", base64Result.isFailure)
        val base64Error = base64Result.exceptionOrNull()
        assertTrue("Should have IllegalArgumentException", base64Error is IllegalArgumentException)
        assertEquals("Should have correct error message", "Size must be positive", base64Error?.message)
    }

    @Test
    fun testZeroSizeHandling() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()

        // Test direct byte generation
        val bytesResult = random.nextBytes(0)
        assertTrue("Should fail with zero size", bytesResult.isFailure)
        val bytesError = bytesResult.exceptionOrNull()
        assertTrue("Should have IllegalArgumentException", bytesError is IllegalArgumentException)
        assertEquals("Should have correct error message", "Size must be positive", bytesError?.message)

        // Test SecureBytes generation
        val secureBytesResult = random.nextSecureBytes(0)
        assertTrue("Should fail with zero size", secureBytesResult.isFailure)
        val secureBytesError = secureBytesResult.exceptionOrNull()
        assertTrue("Should have IllegalArgumentException", secureBytesError is IllegalArgumentException)
        assertEquals("Should have correct error message", "Size must be positive", secureBytesError?.message)

        // Test hex string generation
        val hexResult = EnhancedRandom.generateEnhancedBytesAsHex(context, 0)
        assertTrue("Should fail with zero size", hexResult.isFailure)
        val hexError = hexResult.exceptionOrNull()
        assertTrue("Should have IllegalArgumentException", hexError is IllegalArgumentException)
        assertEquals("Should have correct error message", "Size must be positive", hexError?.message)

        // Test Base64 string generation
        val base64Result = EnhancedRandom.generateEnhancedBytesAsBase64(context, 0)
        assertTrue("Should fail with zero size", base64Result.isFailure)
        val base64Error = base64Result.exceptionOrNull()
        assertTrue("Should have IllegalArgumentException", base64Error is IllegalArgumentException)
        assertEquals("Should have correct error message", "Size must be positive", base64Error?.message)
    }

    @Test
    fun testEnhancedRandomCreationFailure() = runBlocking {
        try {
            // Test with a mock context that throws an exception during KeyStore access
            val mockContext = object : ContextWrapper(context) {
                override fun getApplicationContext(): Context {
                    throw SecurityException("Simulated security error")
                }
            }

            val result = EnhancedRandom.create(mockContext).getOrNull()

            // If we get here, the test should fail because we expected an exception
            assertNull("Creation should have failed", result)

        } catch (e: Exception) {
            // This is the expected path - verify the exception details
            assertTrue(
                "Exception message should mention creation failure",
                e.message?.contains("Failed to create EnhancedRandom") == true
            )
            assertTrue(
                "Exception message should contain original error",
                e.message?.contains("Simulated security error") == true
            )

            // Verify that the cause is our simulated SecurityException
            assertTrue(
                "Root cause should be SecurityException",
                e.cause is SecurityException
            )
            assertEquals(
                "Original error message should match",
                "Simulated security error",
                e.cause?.message
            )
        }
    }

    @Test
    fun testSecureBytesCleanup() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val size = 32

        val secureBytes = random.nextSecureBytes(size).getOrThrow()

        // First use
        var isZeroAfterUse = false
        secureBytes.use { bytes ->
            // Just verify not all zeros initially
            assertFalse("Initial bytes should not be all zeros", bytes.all { it == 0.toByte() })
        }

        // Second use - should be zeroed
        secureBytes.use { bytes ->
            isZeroAfterUse = bytes.all { it == 0.toByte() }
        }

        // Final verification
        assertTrue("Bytes should be zeroed after use", isZeroAfterUse)
    }

    @Test
    fun testSecureBytesZeroization() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val size = 32

        val bytesResult = random.nextSecureBytes(size)
        assertTrue("Secure bytes generation failed", bytesResult.isSuccess)

        val secureBytes = bytesResult.getOrThrow()

        // First use should give us non-zero data
        secureBytes.use { bytes ->
            assertFalse("Initial bytes should not be all zeros", bytes.all { it == 0.toByte() })
        }

        // Second use should give us zeroed data due to cleanup
        secureBytes.use { bytes ->
            assertTrue("Bytes should be zeroed after first use",
                bytes.all { it == 0.toByte() })
        }
    }

    @Test
    fun testDifferentSizes() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()

        // Test various sizes
        val sizes = listOf(1, 16, 64, 1024)

        for (size in sizes) {
            val result = random.nextBytes(size)
            assertTrue("Failed to generate $size bytes", result.isSuccess)

            val bytes = result.getOrThrow()
            assertEquals("Generated size mismatch for request of $size bytes",
                size, bytes.size)

            // Basic non-zero check
            assertFalse("Generated bytes should not be all zeros for size $size",
                bytes.all { it == 0.toByte() })
        }
    }

    @Test
    fun testSequentialHexStrings() = runBlocking {
        val length = 32
        val expectedLength = length * 2
        // Generate multiple hex strings and verify they're all different
        val hexStrings = List(3) {
            EnhancedRandom.generateEnhancedBytesAsHex(context, length).getOrThrow()
        }

        // Verify all strings are different
        val uniqueStrings = hexStrings.toSet()
        assertEquals("Sequential hex strings should all be different",
            hexStrings.size, uniqueStrings.size)

        // Verify they're all valid hex strings of correct length
        for (hexString in hexStrings) {
            assertEquals("Hex string length incorrect", expectedLength, hexString.length)
            assertTrue("Invalid hex string format",
                hexString.matches(Regex("[0-9a-f]+")))
        }
    }

    @Test
    fun testZeroLengthHandling() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()

        // Test both bytes and hex string generation with zero length
        val bytesResult = random.nextBytes(0)
        assertTrue("Should fail with zero size", bytesResult.isFailure)
        assertTrue("Should have IllegalArgumentException for bytes",
            bytesResult.exceptionOrNull() is IllegalArgumentException)

        val hexResult = EnhancedRandom.generateEnhancedBytesAsHex(context, 0)
        assertTrue("Should fail with zero length", hexResult.isFailure)
        assertTrue("Should have IllegalArgumentException for hex",
            hexResult.exceptionOrNull() is IllegalArgumentException)
    }

    // Statistical Quality Tests
    @Test
    fun testByteDistribution() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val size = 25600

        val bytes = random.nextBytes(size).getOrThrow()
        val frequencies = IntArray(256) { 0 }

        bytes.forEach { byte ->
            frequencies[byte.toInt() and 0xFF]++
        }

        // More detailed statistics
        val mean = frequencies.average()
        val stdDev = sqrt(frequencies.map { (it - mean) * (it - mean) }.average())
        val min = frequencies.minOrNull() ?: 0
        val max = frequencies.maxOrNull() ?: 0
        val expectedFreq = size / 256.0

        println("""
        Byte Distribution Statistics:
        ---------------------------
        Sample size: $size
        Expected frequency per byte: $expectedFreq
        Actual frequencies:
        - Mean: $mean
        - Std Dev: $stdDev
        - Min: $min
        - Max: $max
        - Max/Min ratio: ${if (min > 0) max.toDouble() / min else "infinity"}
    """.trimIndent())

        val chiSquare = frequencies.sumOf { freq ->
            val diff = freq - expectedFreq
            (diff * diff) / expectedFreq
        }

        println("Chi-square value: $chiSquare")

        // More reasonable thresholds for practical randomness
        assertTrue("Distribution fails uniformity test (chi-square = $chiSquare)",
            chiSquare < 336.0)
        assertTrue("Some byte values appear too infrequently",
            min > expectedFreq * 0.5)
        assertTrue("Some byte values appear too frequently",
            max < expectedFreq * 1.5)
    }

    private fun sqrt(x: Double): Double = kotlin.math.sqrt(x)

    @Test
    fun testBitCorrelation() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val size = 1000

        // Generate two consecutive sequences
        val bytes1 = random.nextBytes(size).getOrThrow()
        val bytes2 = random.nextBytes(size).getOrThrow()

        // Calculate bit correlations
        var correlationCount = 0
        val totalBits = size * 8

        for (i in 0 until size) {
            for (bit in 0 until 8) {
                val bit1 = (bytes1[i].toInt() shr bit) and 1
                val bit2 = (bytes2[i].toInt() shr bit) and 1
                if (bit1 == bit2) correlationCount++
            }
        }

        val correlationRatio = correlationCount.toDouble() / totalBits
        println("""
        Bit Correlation Analysis:
        ------------------------
        Total bits compared: $totalBits
        Matching bits: $correlationCount
        Correlation ratio: $correlationRatio
        (Expected ~0.5 for random data)
    """.trimIndent())

        // For truly random bits, correlation should be close to 0.5
        assertTrue("Bit correlation too high: $correlationRatio",
            correlationRatio in 0.45..0.55)
    }

    // Performance Tests
    @Test
    fun testHighVolumeGeneration() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val iterations = 100
        val size = 1024 // 1KB each

        val startTime = System.nanoTime()

        // Generate multiple blocks in parallel
        val results = (1..iterations).map {
            random.nextBytes(size)
        }

        val duration = (System.nanoTime() - startTime) / 1_000_000.0 // Convert to ms
        val totalBytes = iterations * size

        println("""
        High Volume Generation Test:
        --------------------------
        Total bytes: $totalBytes
        Iterations: $iterations
        Duration: $duration ms
        Throughput: ${totalBytes / duration * 1000 / 1024} KB/s
    """.trimIndent())

        // Verify all generations succeeded
        assertTrue("All generations should succeed",
            results.all { it.isSuccess })

        // Check that we maintain good performance
        assertTrue("Generation too slow: $duration ms",
            duration < 5000) // Should complete within 5 seconds
    }

    @Test
    fun testMemoryCleanup() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val size = 1024

        // Pre-warm the system and stabilize memory
        repeat(5) {
            random.nextSecureBytes(size).getOrThrow().use { _ -> }
            System.gc()
            System.runFinalization()
            Thread.sleep(100)
        }

        // Get initial memory state
        val initialMemory = Runtime.getRuntime().totalMemory() -
                Runtime.getRuntime().freeMemory()

        // Generate and immediately clear many secure bytes
        repeat(1000) {
            random.nextSecureBytes(size).getOrThrow().use { bytes ->
                // Use bytes and verify they're cleared
                assertFalse("Bytes should not be all zero initially",
                    bytes.all { it == 0.toByte() })
            }
        }

        // Force cleanup
        repeat(5) {
            System.gc()
            System.runFinalization()
            Thread.sleep(100)
        }

        // Check memory usage
        val finalMemory = Runtime.getRuntime().totalMemory() -
                Runtime.getRuntime().freeMemory()

        // Memory usage shouldn't grow dramatically
        val memoryDiff = finalMemory - initialMemory
        println("Memory usage difference: ${memoryDiff / 1024} KB")

        // Use a more realistic threshold for Android
        val maxAllowedDiff = size * 25 // ~25KB allowance
        assertTrue("Memory leak detected: $memoryDiff bytes",
            memoryDiff < maxAllowedDiff)
    }

    @Test
    fun testConcurrentAccess() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val size = 32
        val iterations = 100

        // Generate random bytes concurrently
        val results = coroutineScope {
            List(iterations) {
                async(Dispatchers.Default) {
                    random.nextBytes(size)
                }
            }.awaitAll()
        }

        // Verify all operations succeeded
        assertTrue("All concurrent operations should succeed",
            results.all { it.isSuccess })

        // Verify all results are different
        val uniqueResults = results.map {
            it.getOrThrow().toList()
        }.toSet()

        assertTrue("Concurrent generations should produce unique results",
            uniqueResults.size == iterations)
    }

    // Base64 Generation Test
    @Test
    fun testEnhancedBase64Generation() = runBlocking {
        val length = 24
        val expectedLength = 32

        val result = EnhancedRandom.generateEnhancedBytesAsBase64(context, length)
        assertTrue("Base64 generation failed: ${result.exceptionOrNull()}",
            result.isSuccess)

        val base64String = result.getOrThrow()
        assertEquals("Generated Base64 string length mismatch",
            expectedLength, base64String.length)

        // Verify it's valid Base64
        assertTrue("Invalid Base64 format",
            isValidBase64(base64String))
    }

    @Test
    fun testBase64Variants() = runBlocking {
        // Test cases with different padding requirements:
        // - 24 bytes -> 32 chars (no padding needed)
        // - 25 bytes -> 34 chars (2 padding chars needed)
        // - 26 bytes -> 35 chars (1 padding char needed)
        val testLengths = listOf(24, 25, 26)

        val variants = listOf(
            Base64Flags.Default,
            Base64Flags.NoPadding,
            Base64Flags.UrlSafe,
            Base64Flags.UrlSafeNoPadding
        )

        for (bytesLength in testLengths) {
            for (flags in variants) {
                val result = EnhancedRandom.generateEnhancedBytesAsBase64(
                    context, bytesLength, flags
                )
                assertTrue("Generation failed for $flags with length $bytesLength: ${result.exceptionOrNull()}",
                    result.isSuccess)

                val base64String = result.getOrThrow()

                // Calculate expected length:
                // - For padded variants: ceil(n * 4/3), always multiple of 4
                // - For unpadded variants: ceil(n * 4/3) - padding chars
                val paddingChars = when (bytesLength % 3) {
                    0 -> 0    // No padding needed
                    1 -> 2    // Two padding chars needed
                    2 -> 1    // One padding char needed
                    else -> throw IllegalStateException("Impossible modulo value")
                }

                val expectedLength = 4 * ((bytesLength + 2) / 3)  // Always multiple of 4

                when (flags) {
                    is Base64Flags.Default -> {
                        assertEquals("Length mismatch for Default with $bytesLength bytes",
                            expectedLength, base64String.length)
                        assertTrue("Invalid standard Base64 format",
                            base64String.matches(Regex("[A-Za-z0-9+/=]*")))
                        if (paddingChars > 0) {
                            assertTrue("Missing padding when needed",
                                base64String.endsWith("=".repeat(paddingChars)))
                        } else {
                            assertFalse("Found padding when not needed",
                                base64String.contains("="))
                        }
                    }
                    is Base64Flags.NoPadding -> {
                        assertEquals("Length mismatch for NoPadding with $bytesLength bytes",
                            expectedLength - paddingChars, base64String.length)
                        assertTrue("Invalid unpadded Base64 format",
                            base64String.matches(Regex("[A-Za-z0-9+/]*")))
                        assertFalse("Found padding in NoPadding variant",
                            base64String.contains("="))
                    }
                    is Base64Flags.UrlSafe -> {
                        assertEquals("Length mismatch for UrlSafe with $bytesLength bytes",
                            expectedLength, base64String.length)
                        assertTrue("Invalid URL-safe Base64 format",
                            base64String.matches(Regex("[A-Za-z0-9_\\-=]*")))
                        if (paddingChars > 0) {
                            assertTrue("Missing padding when needed",
                                base64String.endsWith("=".repeat(paddingChars)))
                        } else {
                            assertFalse("Found padding when not needed",
                                base64String.contains("="))
                        }
                    }
                    is Base64Flags.UrlSafeNoPadding -> {
                        assertEquals("Length mismatch for UrlSafeNoPadding with $bytesLength bytes",
                            expectedLength - paddingChars, base64String.length)
                        assertTrue("Invalid URL-safe unpadded Base64 format",
                            base64String.matches(Regex("[A-Za-z0-9_\\-]*")))
                        assertFalse("Found padding in UrlSafeNoPadding variant",
                            base64String.contains("="))
                    }
                }
            }
        }
    }

    @Test
    fun testBase64VariableLengths() = runBlocking {
        // Test various lengths including non-standard ones
        val byteLengths = listOf(8, 16, 24, 32, 40, 44, 64)

        for (byteLength in byteLengths) {
            val result = EnhancedRandom.generateEnhancedBytesAsBase64(context, byteLength)
            assertTrue("Failed to generate for $byteLength bytes: ${result.exceptionOrNull()}",
                result.isSuccess)

            val base64String = result.getOrThrow()

            // Calculate expected Base64 length:
            // 1. First get number of complete 4-char blocks: ceil(n/3) * 4
            val expectedLength = 4 * ((byteLength + 2) / 3)

            // Log for debugging
            println("Input bytes: $byteLength, Base64 length: ${base64String.length}, Expected: $expectedLength")

            assertEquals("Length mismatch for $byteLength input bytes",
                expectedLength, base64String.length)

            // Verify padding based on input length
            val remainder = byteLength % 3
            when (remainder) {
                0 -> assertFalse("Unexpected padding for length $byteLength",
                    base64String.contains("="))
                1 -> assertTrue("Missing double padding for length $byteLength",
                    base64String.endsWith("=="))
                2 -> assertTrue("Missing single padding for length $byteLength",
                    base64String.endsWith("=") && !base64String.endsWith("=="))
            }

            // Verify it's valid Base64
            assertTrue("Invalid Base64 format",
                base64String.matches(Regex("[A-Za-z0-9+/=]*")))
        }
    }

    @Test
    fun testDistinctBase64Sequences() = runBlocking {
        val length = 32
        // Generate multiple Base64 strings and verify they're different
        val base64Strings = List(5) {
            EnhancedRandom.generateEnhancedBytesAsBase64(context, length).getOrThrow()
        }

        val uniqueStrings = base64Strings.toSet()
        assertEquals("Sequential Base64 generations should produce unique strings",
            base64Strings.size, uniqueStrings.size)
    }

    @Test
    fun testUrlSafeBase64Characters() = runBlocking {
        val length = 32
        val result = EnhancedRandom.generateEnhancedBytesAsBase64(
            context,
            length,
            Base64Flags.UrlSafe
        )

        val base64String = result.getOrThrow()
        assertFalse("URL-safe Base64 should not contain '+'",
            base64String.contains("+"))
        assertFalse("URL-safe Base64 should not contain '/'",
            base64String.contains("/"))
        assertTrue("URL-safe Base64 should use '-' and '_'",
            base64String.matches(Regex("[A-Za-z0-9_\\-=]*")))
    }

    @Test
    fun testBase64ErrorCases() = runBlocking {
        // Test negative length
        val negativeResult = EnhancedRandom.generateEnhancedBytesAsBase64(context, -1)
        assertTrue("Should return failure for negative length", negativeResult.isFailure)
        val negativeError = negativeResult.exceptionOrNull()
        assertTrue("Should fail with IllegalArgumentException", negativeError is IllegalArgumentException)
        assertEquals("Should have correct error message", "Size must be positive", negativeError?.message)

        // Test zero length
        val zeroResult = EnhancedRandom.generateEnhancedBytesAsBase64(context, 0)
        assertTrue("Should return failure for zero length", zeroResult.isFailure)
        val zeroError = zeroResult.exceptionOrNull()
        assertTrue("Should fail with IllegalArgumentException", zeroError is IllegalArgumentException)
        assertEquals("Should have correct error message", "Size must be positive", zeroError?.message)
    }

    @Test
    fun testBase64PaddingBehavior() = runBlocking {
        // Test lengths that would require different padding amounts
        val byteLengths = listOf(10, 17, 22) // These lengths mod 3 give different remainders

        for (byteLength in byteLengths) {
            // Test with padding
            val paddedResult = EnhancedRandom.generateEnhancedBytesAsBase64(
                context, byteLength, Base64Flags.Default
            ).getOrThrow()

            // Test without padding
            val unpaddedResult = EnhancedRandom.generateEnhancedBytesAsBase64(
                context, byteLength, Base64Flags.NoPadding
            ).getOrThrow()

            // Calculate expected lengths
            val baseLength = 4 * ((byteLength + 2) / 3)  // Length with padding (multiple of 4)
            val paddingChars = when (byteLength % 3) {
                0 -> 0    // No padding needed
                1 -> 2    // Two padding chars needed
                2 -> 1    // One padding char needed
                else -> throw IllegalStateException("Impossible modulo value")
            }

            // Log for debugging
            println("""
            Input bytes: $byteLength
            Padded length: ${paddedResult.length} (expected: $baseLength)
            Unpadded length: ${unpaddedResult.length} (expected: ${baseLength - paddingChars})
            Padding chars needed: $paddingChars
            Mod 3: ${byteLength % 3}
        """.trimIndent())

            // Verify padded version
            assertEquals("Length mismatch with padding for $byteLength bytes",
                baseLength, paddedResult.length)

            // Verify padding characters
            if (paddingChars > 0) {
                assertTrue("Missing padding characters for $byteLength bytes",
                    paddedResult.endsWith("=".repeat(paddingChars)))
            } else {
                assertFalse("Unexpected padding for $byteLength bytes",
                    paddedResult.contains("="))
            }

            // Verify unpadded version
            assertEquals("Length mismatch without padding for $byteLength bytes",
                baseLength - paddingChars, unpaddedResult.length)
            assertFalse("Unpadded version should not contain padding",
                unpaddedResult.contains("="))

            // Verify both are valid Base64
            assertTrue("Invalid padded Base64 format",
                paddedResult.matches(Regex("[A-Za-z0-9+/=]*")))
            assertTrue("Invalid unpadded Base64 format",
                unpaddedResult.matches(Regex("[A-Za-z0-9+/]*")))
        }
    }

    @Test
    fun testBase64EncodingFailures() = runBlocking {
        // Test each Base64 flag with invalid size
        for (flags in listOf(
            Base64Flags.Default,
            Base64Flags.NoPadding,
            Base64Flags.UrlSafe,
            Base64Flags.UrlSafeNoPadding
        )) {
            val result = EnhancedRandom.generateEnhancedBytesAsBase64(context, -1, flags)
            assertTrue("Should fail with negative size for $flags", result.isFailure)
            val error = result.exceptionOrNull()
            assertTrue("Should have IllegalArgumentException for $flags",
                error is IllegalArgumentException)
            assertEquals("Should have correct error message for $flags",
                "Size must be positive", error?.message)
        }
    }

    private fun isValidBase64(str: String): Boolean {
        return try {
            Base64.decode(str, Base64.DEFAULT)
            true
        } catch (e: IllegalArgumentException) {
            false
        }
    }
}
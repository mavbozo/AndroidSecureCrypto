package com.mavbozo.androidsecurecrypto

import android.content.Context
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4
import kotlinx.coroutines.runBlocking
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import kotlin.system.measureNanoTime

/**
 * Verifies that critical functionality remains intact after ProGuard optimization.
 * This test ensures:
 * 1. Class structure is preserved
 * 2. Random generation works
 * 3. Memory cleanup occurs
 * 4. Error handling functions
 */
@RunWith(AndroidJUnit4::class)
class ProguardVerificationTest {
    private lateinit var context: Context
    private val TEST_SIZE = 32

    @Before
    fun setup() {
        context = InstrumentationRegistry.getInstrumentation().targetContext
    }

    @Test
    fun testBasicFunctionalityAfterProguard() = runBlocking {
        // Part 1: Create Enhanced Random
        val randomResult = EnhancedRandom.create(context)
        assertTrue(
            "Random creation should succeed after ProGuard processing",
            randomResult.isSuccess
        )

        // Part 2: Generate Random Bytes
        val random = randomResult.getOrThrow()
        val bytesResult = random.nextSecureBytes(TEST_SIZE)

        assertTrue(
            "Byte generation should succeed after ProGuard processing",
            bytesResult.isSuccess
        )

        // Part 3: Verify Generated Bytes
        bytesResult.getOrThrow().use { bytes ->
            // Check size
            assertEquals(
                "Generated bytes should have correct size",
                TEST_SIZE,
                bytes.size
            )

            // Verify non-zero (extremely unlikely to be all zeros if working)
            assertFalse(
                "Generated bytes should not be all zeros",
                bytes.all { it == 0.toByte() }
            )
        }

        // Part 4: Generate and verify Base64 string
        val base64Result = EnhancedRandom.generateEnhancedBytesAsBase64(
            context,
            TEST_SIZE,
            Base64Flags.Default
        )

        assertTrue(
            "Base64 generation should succeed after ProGuard processing",
            base64Result.isSuccess
        )

        val base64String = base64Result.getOrThrow()
        assertFalse(
            "Base64 string should not be empty",
            base64String.isEmpty()
        )
    }

    @Test
    fun verifySecureBytesCleanup() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val bytesResult = random.nextSecureBytes(32).getOrThrow()

        var dataRef: ByteArray? = null
        var wasNonZero = false

        bytesResult.use { bytes ->
            dataRef = bytes  // Keep reference to actual bytes

            // Verify we have non-zero content during use
            wasNonZero = bytes.any { it != 0.toByte() }
            assertTrue("Should have non-zero bytes during use", wasNonZero)
        }

        // Now verify cleanup happened after use block
        val wasZeroed = dataRef?.all { it == 0.toByte() } ?: false
        assertTrue(
            "SecureBytes not properly zeroed after use. " +
                    "Had non-zero bytes: $wasNonZero, " +
                    "Was zeroed after: $wasZeroed",
            wasZeroed
        )
    }

    @Test
    fun verifyEntropyQualityPreserved() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()

        // Verify entropy quality enum is preserved
        val quality = random.getQuality()
        assertTrue(
            "Entropy quality should be hardware for EnhancedRandom",
            quality is EntropyQuality.Hardware
        )
    }

    @Test
    fun verifyConstantTimeOperations() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()

        // Generate two different size requests
        val time1 = measureTime {
            random.nextSecureBytes(32).getOrThrow()
        }
        val time2 = measureTime {
            random.nextSecureBytes(64).getOrThrow()
        }

        // Check if generation time is roughly proportional to size
        // This helps verify that optimizations haven't broken timing characteristics
        assertTrue(
            "Generation time should scale roughly linearly",
            time2 < time1 * 3
        ) // Allow some variance but should be roughly linear
    }

    private suspend fun measureTime(block: suspend () -> Unit): Long {
        val start = System.nanoTime()
        block()
        return System.nanoTime() - start
    }

    @Test
    fun testCriticalClassesPreserved() {
        // Verify critical security classes are preserved
        val classes = listOf(
            Random::class.java,
            EnhancedRandom::class.java,
            SecureBytes::class.java,
            EntropyQuality::class.java,
            Base64Flags::class.java
        )

        classes.forEach { clazz ->
            // Check class is accessible
            assertNotNull("Class ${clazz.simpleName} should exist", clazz)

            // Verify method names aren't obfuscated (should be readable)
            val methods = clazz.declaredMethods
            methods.forEach { method ->
                assertFalse(
                    "Method ${method.name} should not be obfuscated",
                    method.name.matches(Regex("^[a-z]{1,2}$"))
                )
            }
        }
    }

    @Test
    fun testSecureBytesCleanup() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val data = random.nextSecureBytes(32).getOrThrow()

        var dataRef: ByteArray? = null

        data.use { bytes ->
            // Keep reference to the actual bytes, not a copy
            dataRef = bytes

            // Verify bytes aren't zeros during use
            assertFalse("Generated bytes should not be all zeros",
                bytes.all { it == 0.toByte() })

            // Remember some non-zero value for later comparison
            assertTrue("Should have some non-zero bytes",
                bytes.any { it != 0.toByte() })
        }

        // After use block, the original bytes should be zeroed
        assertTrue("Original bytes should be zeroed after use",
            dataRef?.all { it == 0.toByte() } ?: false)
    }


    @Test
    fun testTimingSensitiveOperations() {
        runBlocking {
            val random = EnhancedRandom.create(context).getOrThrow()
            val timings = mutableListOf<Long>()

            // Collect multiple timing samples
            repeat(5) {
                val time = measureNanoTime {
                    runBlocking {
                        random.nextSecureBytes(32).getOrThrow().use { bytes ->
                            // Just read the bytes
                            bytes[0]
                        }
                    }
                }
                timings.add(time)
            }

            // Calculate timing variance
            val mean = timings.average()
            val variance = timings.map { (it - mean) * (it - mean) }.average()
            val stdDev = kotlin.math.sqrt(variance)

            // Check for reasonable timing consistency
            // Allow some variance but flag if it's too high (might indicate timing issues)
            assertTrue(
                "Operation timing should be reasonably consistent. " +
                        "High variance might indicate timing vulnerabilities. " +
                        "StdDev: $stdDev, Mean: $mean",
                stdDev / mean < 0.5
            ) // Adjust threshold based on your needs
        }
        Unit
    }

    @Test
    fun testEntropyQualityPreserved() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()

        // EnhancedRandom should always use hardware entropy
        assertTrue(
            "EnhancedRandom should use hardware entropy",
            random.getQuality() is EntropyQuality.Hardware
        )

        // Generate two sequences and verify they're different
        val seq1 = random.nextSecureBytes(32).getOrThrow()
        val seq2 = random.nextSecureBytes(32).getOrThrow()

        seq1.use { bytes1 ->
            seq2.use { bytes2 ->
                assertFalse(
                    "Generated sequences should be different",
                    bytes1.contentEquals(bytes2)
                )
            }
        }
    }

    @Test
    fun verifyMemoryCleanupAfterProguard() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val secureBytes = random.nextSecureBytes(32).getOrThrow()

        var bytesRef: ByteArray? = null

        secureBytes.use { bytes ->
            bytesRef = bytes

            // Verify non-zero content during use
            assertTrue("Should have non-zero content",
                bytes.any { it != 0.toByte() })
        }

        // Verify original bytes were zeroed
        assertTrue("Original bytes should be zeroed after use",
            bytesRef?.all { it == 0.toByte() } ?: false)
    }

    @Test
    fun verifyEntropyQualityAfterProguard() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()

        // Verify hardware quality
        assertTrue(
            "EnhancedRandom should use hardware quality",
            random.getQuality() is EntropyQuality.Hardware
        )

        // Generate two sequences
        val first = random.nextSecureBytes(32).getOrThrow()
        val second = random.nextSecureBytes(32).getOrThrow()

        first.use { bytes1 ->
            second.use { bytes2 ->
                assertFalse(
                    "Random sequences should be different",
                    bytes1.contentEquals(bytes2)
                )

                assertTrue("Random bytes should not be all zeros",
                    bytes1.any { it != 0.toByte() })
            }
        }
    }

    @Test
    fun verifyConsistentTimingAfterProguard() = runBlocking {
        val random = EnhancedRandom.create(context).getOrThrow()
        val timings = mutableListOf<Long>()

        // Collect timing samples
        repeat(5) {
            val time = measureNanoTime {
                random.nextSecureBytes(32).getOrThrow().use { _ -> }
            }
            timings.add(time)
        }

        // Calculate timing variance
        val mean = timings.average()
        val variance = timings.map { (it - mean) * (it - mean) }.average()
        val stdDev = kotlin.math.sqrt(variance)

        // Check timing consistency
        assertTrue(
            "Operation timing should be reasonably consistent. " +
                    "High variance might indicate timing vulnerabilities. " +
                    "StdDev: $stdDev, Mean: $mean",
            stdDev / mean < 0.5 // Allow some variance but flag if too high
        )
    }

    @Test
    fun verifyKeyDerivationBasicFunctionality() = runBlocking {
        // Test key generation for inputs
        val masterKey = ByteArray(32) { it.toByte() }
        try {
            // Test with default parameters
            val defaultResult = KeyDerivation.deriveKey(
                masterKey = masterKey,
                domain = "test.domain",
                context = "test.context"
            )

            assertTrue("Basic key derivation should succeed", defaultResult.isSuccess)
            defaultResult.getOrThrow().use { key ->
                assertEquals("Derived key should have default size", 32, key.size)
                assertFalse("Derived key should not be all zeros", key.all { it == 0.toByte() })
            }

            // Test each HKDF algorithm
            HkdfAlgorithm.entries.forEach { algorithm ->
                val algorithmResult = KeyDerivation.deriveKey(
                    masterKey = masterKey,
                    domain = "test.domain",
                    context = "test.context",
                    algorithm = algorithm
                )

                assertTrue(
                    "Key derivation should succeed with ${algorithm.name}",
                    algorithmResult.isSuccess
                )

                algorithmResult.getOrThrow().use { key ->
                    assertFalse(
                        "${algorithm.name} derived key should not be all zeros",
                        key.all { it == 0.toByte() }
                    )
                }
            }
        } finally {
            masterKey.fill(0)
        }
    }

    @Test
    fun verifyKeyDerivationMemoryCleanup() = runBlocking {
        val masterKey = ByteArray(32) { it.toByte() }
        try {
            val derivedKey = KeyDerivation.deriveKey(
                masterKey = masterKey,
                domain = "test.domain",
                context = "test.context"
            ).getOrThrow()

            var keyRef: ByteArray? = null
            var wasNonZero = false

            derivedKey.use { bytes ->
                keyRef = bytes
                wasNonZero = bytes.any { it != 0.toByte() }
                assertTrue("Should have non-zero bytes during use", wasNonZero)
            }

            assertTrue(
                "Key material should be zeroed after use",
                keyRef?.all { it == 0.toByte() } ?: false
            )
        } finally {
            masterKey.fill(0)
        }
    }

    @Test
    fun verifyKeyDerivationConsistency() {
        runBlocking {
            val masterKey = ByteArray(32) { it.toByte() }
            try {
                // Generate two keys with same parameters
                val key1 = KeyDerivation.deriveKey(
                    masterKey = masterKey,
                    domain = "test.domain",
                    context = "test.context"
                ).getOrThrow()

                val key2 = KeyDerivation.deriveKey(
                    masterKey = masterKey,
                    domain = "test.domain",
                    context = "test.context"
                ).getOrThrow()

                var key1Bytes: ByteArray? = null
                var key2Bytes: ByteArray? = null

                key1.use { bytes1 ->
                    key1Bytes = bytes1.clone()
                }
                key2.use { bytes2 ->
                    key2Bytes = bytes2.clone()
                }

                assertTrue(
                    "Same inputs should produce same key",
                    key1Bytes!!.contentEquals(key2Bytes!!)
                )

                // Clean up cloned bytes
                key1Bytes?.fill(0)
                key2Bytes?.fill(0)
            } finally {
                masterKey.fill(0)
            }
        }
        Unit
    }

    @Test
    fun verifyKeyDerivationErrorHandling() = runBlocking {
        // Test with invalid master key size
        val shortKey = ByteArray(8) { it.toByte() }
        val shortKeyResult = KeyDerivation.deriveKey(
            masterKey = shortKey,
            domain = "test.domain",
            context = "test.context"
        )

        assertTrue("Should fail with short master key", shortKeyResult.isFailure)
        assertTrue(
            "Should have correct error type",
            shortKeyResult.exceptionOrNull() is IllegalArgumentException
        )

        // Test with empty domain
        val validKey = ByteArray(32) { it.toByte() }
        try {
            val emptyDomainResult = KeyDerivation.deriveKey(
                masterKey = validKey,
                domain = "",
                context = "test.context"
            )

            assertTrue("Should fail with empty domain", emptyDomainResult.isFailure)
            assertTrue(
                "Should have correct error type",
                emptyDomainResult.exceptionOrNull() is IllegalArgumentException
            )
        } finally {
            validKey.fill(0)
        }
    }

    @Test
    fun verifyKeyDerivationEnumPreservation() {
        // Verify all enum values are preserved
        val algorithms = HkdfAlgorithm.entries
        assertEquals(
            "Should preserve all HKDF algorithms",
            setOf("SHA256", "SHA512", "SHA1"),
            algorithms.map { it.name }.toSet()
        )

        // Verify enum properties
        algorithms.forEach { algorithm ->
            assertNotNull("HMAC algorithm name should be preserved", algorithm.hmacAlgorithm)
            assertTrue("MAC length should be positive", algorithm.macLength > 0)
        }
    }
}
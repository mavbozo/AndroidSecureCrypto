package com.mavbozo.androidsecurecrypto

import android.content.Context
import androidx.test.core.app.ApplicationProvider
import kotlinx.coroutines.runBlocking
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.MockitoAnnotations
import org.robolectric.RobolectricTestRunner
import java.security.Provider
import java.security.Security
import org.bouncycastle.jce.provider.BouncyCastleProvider

@RunWith(RobolectricTestRunner::class)
class RandomTest {
    private lateinit var context: Context

    // Custom provider just for quality detection
    private class TestAndroidKeyStoreProvider : Provider(
        "AndroidKeyStore",
        1.0,
        "Test Android KeyStore Provider"
    )

    @Before
    fun setup() {
        MockitoAnnotations.openMocks(this)
        context = ApplicationProvider.getApplicationContext()

        // Add providers
        if (Security.getProvider("BC") == null) {
            Security.addProvider(BouncyCastleProvider())
        }

        // Add test provider for quality detection
        if (Security.getProvider("AndroidKeyStore") == null) {
            Security.addProvider(TestAndroidKeyStoreProvider())
        }
    }

    @Test
    fun `test Random creation with hardware quality`() = runBlocking {
        // Add AndroidKeyStore provider to trigger hardware quality
        val randomResult = Random.create()

        assertTrue("Random creation failed", randomResult.isSuccess)
        val random = randomResult.getOrThrow()

        assertEquals("Should detect hardware quality due to AndroidKeyStore presence",
            EntropyQuality.Hardware,
            random.getQuality())
    }

    @Test
    fun `test Random creation with fallback quality`() = runBlocking {
        // Remove AndroidKeyStore provider to trigger fallback quality
        Security.removeProvider("AndroidKeyStore")

        val randomResult = Random.create()
        assertTrue("Random creation failed", randomResult.isSuccess)

        val random = randomResult.getOrThrow()
        assertEquals("Should fall back to software quality",
            EntropyQuality.Fallback,
            random.getQuality())
    }

    @Test
    fun `test generate random bytes`() = runBlocking {
        val size = 32
        val bytesResult = Random.generateBytes(size)

        assertTrue("Generate bytes failed", bytesResult.isSuccess)
        val bytes = bytesResult.getOrThrow()

        assertNotNull("Generated bytes are null", bytes)
        assertEquals("Generated bytes size mismatch", size, bytes.size)
        assertFalse("Generated bytes should not be all zero",
            bytes.all { it == 0.toByte() })
    }

    @Test
    fun `test generate hex string`() = runBlocking {
        val length = 32
        val expectedLength = length * 2
        val hexResult = Random.generateBytesAsHex(length)

        assertTrue("Hex string generation failed", hexResult.isSuccess)
        val hexString = hexResult.getOrThrow()

        assertNotNull("Generated hex string is null", hexString)
        assertEquals("Hex string length mismatch", expectedLength, hexString.length)
        assertTrue("Invalid hex string format",
            hexString.matches(Regex("[0-9a-f]+")))
    }

    @Test
    fun `test secure bytes wrapping and cleanup`() = runBlocking {
        val size = 32
        val randomResult = Random.create()
        assertTrue("Random creation failed", randomResult.isSuccess)

        val random = randomResult.getOrThrow()
        val bytesResult = random.nextSecureBytes(size)
        assertTrue("Secure bytes generation failed", bytesResult.isSuccess)

        val secureBytes = bytesResult.getOrThrow()
        var exposedBytes: ByteArray?

        secureBytes.use { bytes ->
            exposedBytes = bytes.clone()
            assertNotNull("Exposed bytes are null", exposedBytes)
            assertEquals("Exposed bytes size mismatch", size, exposedBytes?.size)
            assertFalse("Bytes should not be all zero before cleanup",
                bytes.all { it == 0.toByte() })
        }

        secureBytes.use { bytes ->
            assertTrue("Bytes not zeroed after use",
                bytes.all { it == 0.toByte() })
        }
    }

    @Test
    fun `test negative size handling`() = runBlocking {
        val negativeSize = -1
        val bytesResult = Random.generateBytes(negativeSize)

        assertTrue("Should fail with negative size", bytesResult.isFailure)
        assertTrue("Should have IllegalArgumentException",
            bytesResult.exceptionOrNull() is IllegalArgumentException)
    }

    // Base64Test
    @Test
    fun `test standard base64 string format`() = runBlocking {
        val length = 32
        val base64Result = Random.generateBytesAsBase64(length, Base64Flags.Default)
        
        assertTrue("Base64 string generation failed", base64Result.isSuccess)
        val base64String = base64Result.getOrThrow()
        
        assertNotNull("Generated base64 string is null", base64String)
        assertTrue("Invalid standard base64 format",
            base64String.matches(Regex("^[A-Za-z0-9+/]+={0,2}$")))
        assertFalse("Should not contain line breaks",
            base64String.contains("\n") || base64String.contains("\r"))
    }

    @Test
    fun `test base64 string without padding`() = runBlocking {
        val length = 32
        val base64Result = Random.generateBytesAsBase64(length, Base64Flags.NoPadding)
        
        assertTrue("Base64 string generation failed", base64Result.isSuccess)
        val base64String = base64Result.getOrThrow()
        
        assertNotNull("Generated base64 string is null", base64String)
        assertTrue("Invalid non-padded base64 format",
            base64String.matches(Regex("^[A-Za-z0-9+/]+$")))
        assertFalse("Should not contain padding",
            base64String.contains("="))
    }

    @Test
    fun `test url safe base64 string format`() = runBlocking {
        val length = 32
        val base64Result = Random.generateBytesAsBase64(length, Base64Flags.UrlSafe)
        
        assertTrue("Base64 string generation failed", base64Result.isSuccess)
        val base64String = base64Result.getOrThrow()
        
        assertNotNull("Generated base64 string is null", base64String)
        assertTrue("Invalid URL-safe base64 format",
            base64String.matches(Regex("^[A-Za-z0-9_-]+={0,2}$")))
        assertFalse("Should not contain URL-unsafe characters",
            base64String.contains("+") || base64String.contains("/"))
    }

    @Test
    fun `test url safe base64 string without padding`() = runBlocking {
        val length = 32
        val base64Result = Random.generateBytesAsBase64(length, Base64Flags.UrlSafeNoPadding)
        
        assertTrue("Base64 string generation failed", base64Result.isSuccess)
        val base64String = base64Result.getOrThrow()
        
        assertNotNull("Generated base64 string is null", base64String)
        assertTrue("Invalid URL-safe non-padded base64 format",
            base64String.matches(Regex("^[A-Za-z0-9_-]+$")))
        assertFalse("Should not contain padding",
            base64String.contains("="))
        assertFalse("Should not contain URL-unsafe characters",
            base64String.contains("+") || base64String.contains("/"))
    }

    @Test
    fun `test padding behavior with different lengths`() = runBlocking {
        val testLengths = listOf(1, 2, 3) // Will produce different padding lengths

        for (length in testLengths) {
            // Test Default (with padding)
            val standardResult = Random.generateBytesAsBase64(length, Base64Flags.Default)
            val standardString = standardResult.getOrThrow()
            val expectedPadding = when (length % 3) {
                0 -> 0
                1 -> 2
                else -> 1
            }
            assertEquals("Wrong padding length for standard encoding",
                expectedPadding,
                standardString.count { it == '=' })

            // Test NoPadding
            val noPaddingResult = Random.generateBytesAsBase64(length, Base64Flags.NoPadding)
            val noPaddingString = noPaddingResult.getOrThrow()
            assertFalse("NoPadding should not contain padding",
                noPaddingString.contains("="))
        }
    }

    @Test
    fun `test base64 string lengths for various inputs`() = runBlocking {
        // Map of input length to expected Base64 output length
        val testCases = mapOf(
            1 to 4,   // 1 byte → "X===" (4 chars)
            2 to 4,   // 2 bytes → "XX==" (4 chars)
            3 to 4,   // 3 bytes → "XXXX" (4 chars)
            4 to 8,   // 4 bytes → "XXXXX===" (8 chars)
            7 to 12,  // 7 bytes → "XXXXXXXXXX==" (12 chars)
            11 to 16  // 11 bytes → "XXXXXXXXXXXXXXXX" (16 chars)
        )

        for ((inputLength, expectedLength) in testCases) {
            val base64Result = Random.generateBytesAsBase64(inputLength)
            assertTrue("Base64 string generation failed for length: $inputLength",
                base64Result.isSuccess)

            val base64String = base64Result.getOrThrow()
            assertEquals("Base64 string length mismatch for input length: $inputLength",
                expectedLength, base64String.length)

            // Verify padding is present when expected
            val expectedPaddingLength = when (inputLength % 3) {
                0 -> 0
                1 -> 2
                2 -> 1
                else -> throw IllegalStateException("Impossible modulo result")
            }
            assertEquals("Incorrect padding length for input length: $inputLength",
                expectedPaddingLength,
                base64String.count { it == '=' })
        }
    }

    @Test
    fun `test base64 string with zero length`() = runBlocking {
        try {
            Random.generateBytesAsBase64(0).getOrThrow()
            fail("Should throw IllegalArgumentException")
        } catch (e: IllegalArgumentException) {
            assertEquals("Size must be positive", e.message)
        }
    }

    @Test
    fun `test base64 string with negative length`() = runBlocking {
        val negativeValues = listOf(-1, -42, Int.MIN_VALUE)

        for (negativeLength in negativeValues) {
            try {
                Random.generateBytesAsBase64(negativeLength).getOrThrow()
                fail("Should throw IllegalArgumentException for length $negativeLength")
            } catch (e: IllegalArgumentException) {
                assertEquals(
                    "Invalid error message for length $negativeLength",
                    "Size must be positive",
                    e.message
                )
            }
        }
    }

    @Test
    fun `test base64 string uniqueness`() = runBlocking {
        val length = 32
        val count = 5
        val generated = mutableSetOf<String>()

        repeat(count) {
            val base64Result = Random.generateBytesAsBase64(length)
            assertTrue("Base64 string generation failed", base64Result.isSuccess)

            val base64String = base64Result.getOrThrow()
            assertTrue("Generated base64 string should be unique",
                generated.add(base64String))
        }
    }

    @Test
    fun `test base64 string memory cleanup`() = runBlocking {
        val length = 32
        val base64Result = Random.generateBytesAsBase64(length)
        assertTrue("Base64 string generation failed", base64Result.isSuccess)

        // Verify the internal byte array was cleaned up by checking heap
        System.gc() // Request garbage collection

        // This is a basic check - the actual cleanup is verified more thoroughly
        // in the SecureBytes tests
        val base64String = base64Result.getOrThrow()
        assertNotNull("Generated base64 string should exist after cleanup",
            base64String)
    }
}